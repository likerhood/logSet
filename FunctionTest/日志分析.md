# 总日志分析
## 1. 总日志txt特点
- `bugreport-`开头
- 大约两百万行日志
- 包含唤醒方案等相关文字信息
- 包含其他系统信息
## 2. 需求分析
1. 可以得到唤醒方案、算法、机型等数据；
2. 可以筛选出某一时刻在某一时间段内的全部有效日志；
    - 全部有效日志是指包含voicetrigger项目中关键log打印的关键词；
    - 全部关键词放在一个json文件中；
    - 难点：
        **快速获得有效时间内的全部日志（前后7分钟内日志大约30万行）**
3. 分析日志具体的日志问题：
    - 未收到一级唤醒事件；
    - 一级事件不通过；
    - 二级事件不通过。
        
        
## 3. 难点解决办法
如何**快速**获得有效日志（前后7分钟内日志大约30万行）
### 3.1 问题解决流程
> 本质：**两次日志筛选（有效时间内日志+有效关键词日志）**
1. 正则匹配获得日志时间
    OK
2. **快速获得有效时间范围内的全部日志（重难点）**
    OK
3. 正则匹配 + 有效日志关键词筛选得到最终有效日志
    OK

### 3.2 **筛选有效时间内日志**
> ~~**二分法**快速锁定某一范围的日志（筛选的日志有遗漏，需要其他优化方法）~~

> 问题抽象：**对于不是完全按照时间顺序的日志，如何快速筛选一段时间内的有效日志**
1. 解决思路：**首次筛选——宁滥勿缺**
2. 算法设计：
    - step1. 每次判断第`i`条日志和第`i+1`条日志是否在有效时间内；
    - step2. **若以上两条日志中任意一条符合条件，将这2000条日志都存储起来**；
    - step3. **若以上两条日志都不符合条件**，直接舍弃这里的2000条日志（**一段有效且连续在一分钟内的日志一定大于2000行**）
3. 效率对比：
    1. 逐行遍历时间复杂度为`O(n)`
    2. 间隔2000行粗略筛选，时间复杂度为`O(n/2000)`
    3. 为什么是选择间隔2000行。因为我发现一段有效且连续在一分钟内的日志一定大于2000行。
        

### 3.3 **筛选有有效关键词的日志**
将全部有关voicetrigger项目的日志关键词保存在一个json文件中，然后将第一次筛选出在有效时间范围内的日志逐一遍历匹配筛选。


### 3.4 关键代码
代码路径：FunctionTest\effective_log_extraction\bugreport_analysis.py
代码功能：快速获取关键日志
```python
import re
import datetime

# 正则表达式用于匹配时间戳，不包括毫秒部分
timestamp_pattern = re.compile(r'(\d{2}-\d{2} \d{2}:\d{2}:\d{2})')

def parse_log_timestamp(line):
    match = timestamp_pattern.search(line)
    if match:
        timestamp_str = match.group(1)
        return datetime.datetime.strptime(timestamp_str, '%m-%d %H:%M:%S').replace(year=datetime.datetime.now().year)
    return None

def extract_logs(filename, target_time_str, pre_delta_minutes=3, post_delta_minutes=2):
    with open(filename, 'r', encoding="utf-8") as file:
        lines = file.readlines()

    target_time = datetime.datetime.strptime(target_time_str, '%m-%d %H:%M:%S').replace(year=datetime.datetime.now().year)
    # 前3分钟
    pre_delta = datetime.timedelta(minutes=pre_delta_minutes)
    # 后2分钟
    post_delta = datetime.timedelta(minutes=post_delta_minutes)
    
    start_time = target_time - pre_delta
    end_time = target_time + post_delta

    result_lines = []
    step = 2000
    total_lines = len(lines)
    i = 0

    while i < total_lines:
        # 获取当前位置和1000行后的时间戳
        current_time = parse_log_timestamp(lines[i])
        next_i = min(i + step, total_lines - 1)
        next_time = parse_log_timestamp(lines[next_i])

        if (current_time and start_time <= current_time <= end_time) or (next_time and start_time <= next_time <= end_time):
            
            result_lines.extend(lines[i:next_i + 1])
            
        i += step

    return result_lines

# 示例使用
log_filename = 'bugreport-goku-UKQ1.240116.001-2024-07-06-22-06-59.txt'
target_time_str = '07-06 22:04:40'
pre_delta_minutes = 3
post_delta_minutes = 3
logs = extract_logs(log_filename, target_time_str, pre_delta_minutes, post_delta_minutes)


# 筛选包含关键词的日志
def filter_logs_by_keywords(logs, keywords):
    filtered_logs = []
    for line in logs:
        if any(keyword in line for keyword in keywords):
            filtered_logs.append(line)
    return filtered_logs


# 读取关键词JSON文件
with open('voicetrigger_keywords.json', 'r', encoding="utf-8") as file:
    keywords_data = json.load(file)
keywords = keywords_data['keywords']

# 将提取的日志输出到一个新的文件
# with open('output.txt', 'w', encoding="utf-8") as output_file:
#     output_file.writelines(logs)

# 筛选包含关键词的日志
filtered_logs = filter_logs_by_keywords(logs, keywords)

# 将筛选后的日志输出到一个新的文件
with open('new_filtered_output.txt', 'w', encoding="utf-8") as output_file:
    output_file.writelines(filtered_logs)
```


## 4. 日志问题关键词匹配
### 4.1 得到唤醒方案、机型等文字信息
**只有收到一级唤醒事件才能匹配到有关信息。**
- voice_trigger_version信息
    1. 关键日志：
        ```
        # voice_trigger_version
        Package [com.miui.voicetrigger] (8c57a04):
        appId=10181
        pkg=Package{a5a5bed com.miui.voicetrigger}
        codePath=/product/app/VoiceTrigger
        resourcePath=/product/app/VoiceTrigger
        legacyNativeLibraryDir=/product/app/VoiceTrigger/lib
        extractNativeLibs=true
        primaryCpuAbi=arm64-v8a
        secondaryCpuAbi=null
        cpuAbiOverride=null
        versionCode=2024060310 minSdk=26 targetSdk=33
        minExtensionVersions=[]
        versionName=v-5.9.0.11-qcom
        ```
    2. 关键代码
        ```python
        if not is_get_package_info and re.search('Package \[com.miui.voicetrigger\]', self.log_lines[i]) is not None:
            self.build_date = self.log_lines[i+10].split('=')[1]
            self.voice_trigger_version = self.log_lines[i+12].split('=')[1:]
            is_get_package_info = True
        ```


### 4.2 未收到一级唤醒事件
四种方案通用
未查询到关键日志点‘onRecognition:’，则标记为：未接收到一级事件
1. **关键日志**
    ```bash
    (高通/自研E) D/SVA-LegacyWakeupSession - onRecognition: recognitionEvent = KeyphraseRecognitionEvent [keyphraseExtras=[KeyphraseRecognitionExtra [id=0, recognitionModes=3, coarseConfidenceLevel=98, confidenceLevels=[ConfidenceLevel [userId=1, confidenceLevel=14]]]], status=0, soundModelHandle=1, captureAvailable=true, captureSession=25, captureDelayMs=0, capturePreambleMs=0, triggerInData=false, sampleRate=16000, encoding=2, channelMask=16, data=8944]
    (MTK) V/VoiceTriggerManager - onRecognition: GenericRecognitionEvent ::RecognitionEvent [status=0, soundModelHandle=-1, captureAvailable=false, captureSession=-1, captureDelayMs=-1, capturePreambleMs=-1, triggerInData=false, sampleRate=16000, encoding=2, channelMask=1, data=0]
    (MTK自研) V/MTKVoiceTriggerManager - onRecognition: GenericRecognitionEvent ::RecognitionEvent [status=0, soundModelHandle=-1, captureAvailable=false, captureSession=297, captureDelayMs=8704, capturePreambleMs=-1, triggerInData=false, sampleRate=16000, encoding=2, channelMask=1, data=0] false
    ```

### 4.3 一级唤醒事件



### 4.4 二级唤醒事件

